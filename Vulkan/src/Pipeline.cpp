#include "Pipeline.h"
#include "Device.h"
#include "SwapChain.h"
#include "Core/ManagerImple.h"


KGR::_Vulkan::Pipeline::Pipeline(const ShaderInfo& shaderInfo, Device* device, SwapChain* swapChain, vk::raii::DescriptorSetLayout& layout)
{
	auto& file = fileManager::Load(shaderInfo.ShaderPath);
	file.seekg(0, std::ios::end);
	auto fileSize = file.tellg();
	std::vector<char> buffer(fileSize);
	file.seekg(0, std::ios::beg);
	file.read(buffer.data(), static_cast<std::streamsize>(buffer.size()));
	file.close();
	fileManager::Unload(shaderInfo.ShaderPath);

	vk::ShaderModuleCreateInfo createInfo{
		.codeSize = buffer.size() * sizeof(char),
		.pCode = reinterpret_cast<const uint32_t*>(buffer.data()) };
	vk::raii::ShaderModule shaderModule{ device->Get(), createInfo };

	vk::PipelineShaderStageCreateInfo vertShaderStageInfo{ .stage = vk::ShaderStageFlagBits::eVertex, .module = shaderModule, .pName = shaderInfo.vertexMain };
	vk::PipelineShaderStageCreateInfo fragShaderStageInfo{ .stage = vk::ShaderStageFlagBits::eFragment, .module = shaderModule, .pName = shaderInfo.fragmentMain };
	vk::PipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

	auto                                     bindingDescription = Vertex::getBindingDescription();
	auto                                     attributeDescriptions = Vertex::getAttributeDescriptions();
	vk::PipelineVertexInputStateCreateInfo   vertexInputInfo{ .vertexBindingDescriptionCount = 1, .pVertexBindingDescriptions = &bindingDescription, .vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescriptions.size()), .pVertexAttributeDescriptions = attributeDescriptions.data() };
	vk::PipelineInputAssemblyStateCreateInfo inputAssembly{ .topology = vk::PrimitiveTopology::eTriangleList };
	vk::PipelineViewportStateCreateInfo      viewportState{ .viewportCount = 1, .scissorCount = 1 };

	vk::PipelineRasterizationStateCreateInfo rasterizer{ .depthClampEnable = vk::False, .rasterizerDiscardEnable = vk::False, .polygonMode = vk::PolygonMode::eFill, .cullMode = vk::CullModeFlagBits::eBack, .frontFace = vk::FrontFace::eCounterClockwise, .depthBiasEnable = vk::False, .depthBiasSlopeFactor = 1.0f, .lineWidth = 1.0f };

	vk::PipelineMultisampleStateCreateInfo multisampling{ .rasterizationSamples = vk::SampleCountFlagBits::e1, .sampleShadingEnable = vk::False };

	vk::PipelineColorBlendAttachmentState colorBlendAttachment{ .blendEnable = vk::False,
		.colorWriteMask = vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG | vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA };

	vk::PipelineColorBlendStateCreateInfo colorBlending{ .logicOpEnable = vk::False, .logicOp = vk::LogicOp::eCopy, .attachmentCount = 1, .pAttachments = &colorBlendAttachment };

	std::vector dynamicStates = {
		vk::DynamicState::eViewport,
		vk::DynamicState::eScissor };
	vk::PipelineDynamicStateCreateInfo dynamicState{ .dynamicStateCount = static_cast<uint32_t>(dynamicStates.size()), .pDynamicStates = dynamicStates.data() };

	vk::PipelineLayoutCreateInfo pipelineLayoutInfo{ .setLayoutCount = 1,
		.pSetLayouts = &*layout,
		
		.pushConstantRangeCount = 0 };

	m_layout = vk::raii::PipelineLayout(device->Get(), pipelineLayoutInfo);

	vk::StructureChain<vk::GraphicsPipelineCreateInfo, vk::PipelineRenderingCreateInfo> pipelineCreateInfoChain = {
		{.stageCount = 2,
			.pStages = shaderStages,
			.pVertexInputState = &vertexInputInfo,
			.pInputAssemblyState = &inputAssembly,
			.pViewportState = &viewportState,
			.pRasterizationState = &rasterizer,
			.pMultisampleState = &multisampling,
			.pColorBlendState = &colorBlending,
			.pDynamicState = &dynamicState,
			.layout = m_layout,
			.renderPass = nullptr},
		{.colorAttachmentCount = 1, .pColorAttachmentFormats = &swapChain->GetFormat().format} };

	m_pipeline = vk::raii::Pipeline(device->Get(), nullptr, pipelineCreateInfoChain.get<vk::GraphicsPipelineCreateInfo>());
}

KGR::_Vulkan::Pipeline::vkPipelineLayout& KGR::_Vulkan::Pipeline::GetLayout()
{
	return m_layout;
}

const KGR::_Vulkan::Pipeline::vkPipelineLayout& KGR::_Vulkan::Pipeline::GetLayout() const
{
	return m_layout;
}

KGR::_Vulkan::Pipeline::vkPipeline& KGR::_Vulkan::Pipeline::Get()
{
	return m_pipeline;
}

const KGR::_Vulkan::Pipeline::vkPipeline& KGR::_Vulkan::Pipeline::Get() const
{
	return m_pipeline;
}
